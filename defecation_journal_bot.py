# -*- coding: utf-8 -*-
"""defecation_journal_test.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/12gXR5TT2K0ProjPOJD9aCIW7nnF3PF5d
"""

# 👇 Instala automáticamente los paquetes si faltan
!pip install -q feedparser python-telegram-bot openai nest_asyncio

import openai
import feedparser
import telegram
import asyncio
from datetime import datetime
import random
import nest_asyncio

# 🧩 Para ejecución en Colab
nest_asyncio.apply()

# 🔐 Configuración
OPENAI_API_KEY   = "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"
TELEGRAM_TOKEN   = "8129182291:AAHAPZBznw-NHQBfO6IDa6bwMpbr_fCHF94"
TELEGRAM_CHAT_ID = "@defecation_journal_es"

openai_client = openai.AsyncOpenAI(api_key=OPENAI_API_KEY)
bot = telegram.Bot(token=TELEGRAM_TOKEN)

RSS_FEEDS = {
    "nacional": [
        "https://www.abc.es/rss/feeds/abc_Espana.xml",
        "https://www.elmundo.es/rss/espana.xml",
        "https://www.lavanguardia.com/mvc/feed/rss/politica.xml",
        "https://www.eldiario.es/rss/",
        "https://feeds.elpais.com/mrss-s/pages/ep/site/elpais.com/section/espana/portada",
        "https://rss.elconfidencial.com/espana/"
    ],
    "internacional": [
        "https://feeds.elpais.com/mrss-s/pages/ep/site/elpais.com/section/internacional/portada",
        "https://www.eldiario.es/internacional/rss/",
        "https://www.europapress.es/rss/rss.aspx?ch=68",
        "https://www.lavanguardia.com/mvc/feed/rss/internacional.xml"
    ],
    "economia": [
        "https://e00-expansion.uecdn.es/rss/economia.xml",
        "https://www.eleconomista.es/rss/rss-economia.php",
        "https://cincodias.elpais.com/seccion/economia/rss.xml"
    ],
    "wtf": [
        "https://verne.elpais.com/rss/lo-mas.xml",
        "https://www.eldiario.es/caballodenietzsche/rss/",
        "https://www.publico.es/rss/agencias/cultura/",
        "https://nmas1.org/feed"
    ]
}

def obtener_titulares():
    entradas = {k: [] for k in RSS_FEEDS.keys()}
    for categoria, urls in RSS_FEEDS.items():
        for url in urls:
            if len(entradas[categoria]) >= 3:
                break
            feed = feedparser.parse(url)
            for entrada in feed.entries:
                if len(entradas[categoria]) >= 3:
                    break
                if 'title' in entrada and all(ord(c) < 128 or c in 'áéíóúñÁÉÍÓÚÑüÜ¿¡ ' for c in entrada.title):
                    entradas[categoria].append({
                        "categoria": categoria,
                        "titulo": entrada.title.strip(),
                        "link": entrada.link
                    })
    resultado = []
    for cat in entradas:
        resultado.extend(entradas[cat])
    return resultado

def crear_prompt_para_openai(titulares, momento):
    instrucciones = f"""
Eres un redactor sarcástico para un canal de Telegram llamado "Defecation Journal". Genera un párrafo por noticia que combine resumen serio + comentario sarcástico, en este formato:

📌 *Título*
📰 [Resumen serio + comentario sarcástico]
🔗 Enlace

Clasificación: Nacional, Internacional, Economía y WTF. Humor moderno, español, directo. Markdown de Telegram. No repitas frases.

Momento del día: {momento}
Noticias:
"""
    for t in titulares:
        instrucciones += f"\n[{t['categoria'].upper()}] {t['titulo']} - {t['link']}"
    return instrucciones

def crear_mensaje_final(titulares, cuerpo_generado, momento):
    intro = {
        "mañana": "¡Buenos días! Aquí tienes la edición matinal del *Defecation Journal*, el diario que lees mientras haces lo que nadie más quiere hablar.",
        "tarde": "¡Hora de la pausa! Llega la edición vespertina del *Defecation Journal*, ideal para esos momentos donde el baño es tu sala de prensa privada.",
        "noche": "¡Bienvenidos a la edición nocturna del *Defecation Journal*! El resumen perfecto para cerrar el día mientras reflexionas... en el trono."
    }

    secciones = {
        "nacional": "🇪🇸 Nacional",
        "internacional": "🌍 Internacional",
        "economia": "💰 Economía",
        "wtf": "🫠 WTF"
    }

    ctas = {
        "mañana": "☀️ *Empieza el día defecando con criterio.*",
        "tarde": "🍽️ *Haz una pausa y digiere el mundo con humor.*",
        "noche": "🌙 *Duerme tranquilo, el mundo ya apesta sin ti.*"
    }

    cuerpo_seccionado = {k: [] for k in secciones}
    bloques = cuerpo_generado.strip().split("📌 ")[1:]

    # ✅ Clasificación automática por orden
    categorias = ["nacional", "internacional", "economia", "wtf"]
    index = 0
    for i, bloque in enumerate(bloques):
        cat = categorias[index]
        cuerpo_seccionado[cat].append("📌 " + bloque.strip())
        if len(cuerpo_seccionado[cat]) == 3 and index < 3:
            index += 1

    cierre = random.choice([
        "Recuerda: la vida es como el papel higiénico, a veces estás en el rollo... y otras te lo quitan.",
        "Gracias por leer donde más se piensa. ¡Hasta la próxima sentada!",
        "No olvides tirar de la cadena... y de este canal. 💩"
    ])

    texto = f"💩 *Defecation Journal — Edición de la {momento}*\n\n{intro[momento]}\n\n"
    for cat in categorias:
        if cuerpo_seccionado[cat]:
            texto += f"{secciones[cat]}\n\n"
            texto += "\n\n".join(cuerpo_seccionado[cat]) + "\n\n"
            texto += "— — — — — — — — —\n\n"
    texto += f"🎭 {cierre}\n\n{ctas[momento]}"
    return texto

async def generar_resumen_con_openai(prompt):
    response = await openai_client.chat.completions.create(
        model="gpt-4o",
        messages=[{"role": "user", "content": prompt}],
        temperature=0.9
    )
    content = response.choices[0].message.content
    print("🧠 Respuesta OpenAI:\n", content[:1000])  # Primeros 1000 caracteres
    return content

async def publicar():
    print("📰 Cargando titulares...")
    titulares = obtener_titulares()

    hora = datetime.now().hour
    momento = "mañana" if hora < 12 else "tarde" if hora < 20 else "noche"

    prompt = crear_prompt_para_openai(titulares, momento)
    print("✍️ Generando con GPT-4o...")
    cuerpo = await generar_resumen_con_openai(prompt)

    mensaje = crear_mensaje_final(titulares, cuerpo, momento)
    print("📤 Enviando a Telegram...")

    try:
        await bot.send_message(chat_id=TELEGRAM_CHAT_ID, text=mensaje, parse_mode="Markdown", disable_web_page_preview=True)
        print("✅ Publicado correctamente.")
    except telegram.error.BadRequest as e:
        if "Message is too long" in str(e):
            partes = [mensaje[i:i+4000] for i in range(0, len(mensaje), 4000)]
            for parte in partes:
                await bot.send_message(chat_id=TELEGRAM_CHAT_ID, text=parte, parse_mode="Markdown", disable_web_page_preview=True)
        else:
            print(f"❌ Error de Telegram: {e}")

# ⏩ Ejecutar desde Colab
await publicar()