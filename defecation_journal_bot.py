# -*- coding: utf-8 -*-
"""defecation_journal_test.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/12gXR5TT2K0ProjPOJD9aCIW7nnF3PF5d
"""

# ðŸ‘‡ Instala automÃ¡ticamente los paquetes si faltan
!pip install -q feedparser python-telegram-bot openai nest_asyncio

import openai
import feedparser
import telegram
import asyncio
from datetime import datetime
import random
import nest_asyncio

# ðŸ§© Para ejecuciÃ³n en Colab
nest_asyncio.apply()

# ðŸ” ConfiguraciÃ³n
OPENAI_API_KEY   = "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"
TELEGRAM_TOKEN   = "8129182291:AAHAPZBznw-NHQBfO6IDa6bwMpbr_fCHF94"
TELEGRAM_CHAT_ID = "@defecation_journal_es"

openai_client = openai.AsyncOpenAI(api_key=OPENAI_API_KEY)
bot = telegram.Bot(token=TELEGRAM_TOKEN)

RSS_FEEDS = {
    "nacional": [
        "https://www.abc.es/rss/feeds/abc_Espana.xml",
        "https://www.elmundo.es/rss/espana.xml",
        "https://www.lavanguardia.com/mvc/feed/rss/politica.xml",
        "https://www.eldiario.es/rss/",
        "https://feeds.elpais.com/mrss-s/pages/ep/site/elpais.com/section/espana/portada",
        "https://rss.elconfidencial.com/espana/"
    ],
    "internacional": [
        "https://feeds.elpais.com/mrss-s/pages/ep/site/elpais.com/section/internacional/portada",
        "https://www.eldiario.es/internacional/rss/",
        "https://www.europapress.es/rss/rss.aspx?ch=68",
        "https://www.lavanguardia.com/mvc/feed/rss/internacional.xml"
    ],
    "economia": [
        "https://e00-expansion.uecdn.es/rss/economia.xml",
        "https://www.eleconomista.es/rss/rss-economia.php",
        "https://cincodias.elpais.com/seccion/economia/rss.xml"
    ],
    "wtf": [
        "https://verne.elpais.com/rss/lo-mas.xml",
        "https://www.eldiario.es/caballodenietzsche/rss/",
        "https://www.publico.es/rss/agencias/cultura/",
        "https://nmas1.org/feed"
    ]
}

def obtener_titulares():
    entradas = {k: [] for k in RSS_FEEDS.keys()}
    for categoria, urls in RSS_FEEDS.items():
        for url in urls:
            if len(entradas[categoria]) >= 3:
                break
            feed = feedparser.parse(url)
            for entrada in feed.entries:
                if len(entradas[categoria]) >= 3:
                    break
                if 'title' in entrada and all(ord(c) < 128 or c in 'Ã¡Ã©Ã­Ã³ÃºÃ±ÃÃ‰ÃÃ“ÃšÃ‘Ã¼ÃœÂ¿Â¡ ' for c in entrada.title):
                    entradas[categoria].append({
                        "categoria": categoria,
                        "titulo": entrada.title.strip(),
                        "link": entrada.link
                    })
    resultado = []
    for cat in entradas:
        resultado.extend(entradas[cat])
    return resultado

def crear_prompt_para_openai(titulares, momento):
    instrucciones = f"""
Eres un redactor sarcÃ¡stico para un canal de Telegram llamado "Defecation Journal". Genera un pÃ¡rrafo por noticia que combine resumen serio + comentario sarcÃ¡stico, en este formato:

ðŸ“Œ *TÃ­tulo*
ðŸ“° [Resumen serio + comentario sarcÃ¡stico]
ðŸ”— Enlace

ClasificaciÃ³n: Nacional, Internacional, EconomÃ­a y WTF. Humor moderno, espaÃ±ol, directo. Markdown de Telegram. No repitas frases.

Momento del dÃ­a: {momento}
Noticias:
"""
    for t in titulares:
        instrucciones += f"\n[{t['categoria'].upper()}] {t['titulo']} - {t['link']}"
    return instrucciones

def crear_mensaje_final(titulares, cuerpo_generado, momento):
    intro = {
        "maÃ±ana": "Â¡Buenos dÃ­as! AquÃ­ tienes la ediciÃ³n matinal del *Defecation Journal*, el diario que lees mientras haces lo que nadie mÃ¡s quiere hablar.",
        "tarde": "Â¡Hora de la pausa! Llega la ediciÃ³n vespertina del *Defecation Journal*, ideal para esos momentos donde el baÃ±o es tu sala de prensa privada.",
        "noche": "Â¡Bienvenidos a la ediciÃ³n nocturna del *Defecation Journal*! El resumen perfecto para cerrar el dÃ­a mientras reflexionas... en el trono."
    }

    secciones = {
        "nacional": "ðŸ‡ªðŸ‡¸ Nacional",
        "internacional": "ðŸŒ Internacional",
        "economia": "ðŸ’° EconomÃ­a",
        "wtf": "ðŸ«  WTF"
    }

    ctas = {
        "maÃ±ana": "â˜€ï¸ *Empieza el dÃ­a defecando con criterio.*",
        "tarde": "ðŸ½ï¸ *Haz una pausa y digiere el mundo con humor.*",
        "noche": "ðŸŒ™ *Duerme tranquilo, el mundo ya apesta sin ti.*"
    }

    cuerpo_seccionado = {k: [] for k in secciones}
    bloques = cuerpo_generado.strip().split("ðŸ“Œ ")[1:]

    # âœ… ClasificaciÃ³n automÃ¡tica por orden
    categorias = ["nacional", "internacional", "economia", "wtf"]
    index = 0
    for i, bloque in enumerate(bloques):
        cat = categorias[index]
        cuerpo_seccionado[cat].append("ðŸ“Œ " + bloque.strip())
        if len(cuerpo_seccionado[cat]) == 3 and index < 3:
            index += 1

    cierre = random.choice([
        "Recuerda: la vida es como el papel higiÃ©nico, a veces estÃ¡s en el rollo... y otras te lo quitan.",
        "Gracias por leer donde mÃ¡s se piensa. Â¡Hasta la prÃ³xima sentada!",
        "No olvides tirar de la cadena... y de este canal. ðŸ’©"
    ])

    texto = f"ðŸ’© *Defecation Journal â€” EdiciÃ³n de la {momento}*\n\n{intro[momento]}\n\n"
    for cat in categorias:
        if cuerpo_seccionado[cat]:
            texto += f"{secciones[cat]}\n\n"
            texto += "\n\n".join(cuerpo_seccionado[cat]) + "\n\n"
            texto += "â€” â€” â€” â€” â€” â€” â€” â€” â€”\n\n"
    texto += f"ðŸŽ­ {cierre}\n\n{ctas[momento]}"
    return texto

async def generar_resumen_con_openai(prompt):
    response = await openai_client.chat.completions.create(
        model="gpt-4o",
        messages=[{"role": "user", "content": prompt}],
        temperature=0.9
    )
    content = response.choices[0].message.content
    print("ðŸ§  Respuesta OpenAI:\n", content[:1000])  # Primeros 1000 caracteres
    return content

async def publicar():
    print("ðŸ“° Cargando titulares...")
    titulares = obtener_titulares()

    hora = datetime.now().hour
    momento = "maÃ±ana" if hora < 12 else "tarde" if hora < 20 else "noche"

    prompt = crear_prompt_para_openai(titulares, momento)
    print("âœï¸ Generando con GPT-4o...")
    cuerpo = await generar_resumen_con_openai(prompt)

    mensaje = crear_mensaje_final(titulares, cuerpo, momento)
    print("ðŸ“¤ Enviando a Telegram...")

    try:
        await bot.send_message(chat_id=TELEGRAM_CHAT_ID, text=mensaje, parse_mode="Markdown", disable_web_page_preview=True)
        print("âœ… Publicado correctamente.")
    except telegram.error.BadRequest as e:
        if "Message is too long" in str(e):
            partes = [mensaje[i:i+4000] for i in range(0, len(mensaje), 4000)]
            for parte in partes:
                await bot.send_message(chat_id=TELEGRAM_CHAT_ID, text=parte, parse_mode="Markdown", disable_web_page_preview=True)
        else:
            print(f"âŒ Error de Telegram: {e}")

# â© Ejecutar desde Colab
await publicar()